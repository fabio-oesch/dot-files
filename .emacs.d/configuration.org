#+TITLE: Emacs Configuration
#+AUTHOR: Fabio Oesch
#+OPTIONS: toc:nil num:nil

* Disclaimer

  This was originally created by Harry R. Schwartz and adapted for my own
  purposes. The original can be found [[https://github.com/hrs/dotfiles][here]].

* Configure =use-package=

  I use =use-package= to install and configure my packages. My =init.el=
  includes the initial setup for =package.el= and ensures that =use-package= is
  installed, since I wanna do that right away.

  This makes sure that =use-package= will install the package if it's not
  already available. It also means that I should be able to open Emacs for the
  first time on a fresh Debian box and have my whole environment automatically
  installed. I'm not /totally/ sure about that, but we're gettin' close.

  #+BEGIN_SRC emacs-lisp
    (setq use-package-always-ensure t)
  #+END_SRC

  Always compile packages, and use the newest version available.

  #+BEGIN_SRC emacs-lisp
    (use-package auto-compile
      :config (auto-compile-on-load-mode))

    (setq load-prefer-newer t)
  #+END_SRC

* Use =sensible-defaults.el=

  Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings. The file can be found [[file:~/dev/elisp/sensible-defaults/sensible-defaults.el][here]].

  #+BEGIN_SRC emacs-lisp
    (load-file "~/dev/elisp/sensible-defaults/sensible-defaults.el")
    (sensible-defaults/use-all-settings)
    (sensible-defaults/use-all-keybindings)
    (sensible-defaults/backup-to-temp-directory)
  #+END_SRC

** whoami

   #+BEGIN_SRC emacs-lisp
     (setq user-full-name "Fabio L. Oesch")
   #+END_SRC

* Add =keychain=

  The =keychain-environment= uses the keychain which is provided by funtoo. This
  way the ssh key does not need to be entered when commiting every time.

  #+BEGIN_SRC emacs-lisp
  (use-package keychain-environment
    :init
    (keychain-refresh-environment))
  #+END_SRC

* =evil-mode=

  I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
  usually not what I want. In particular, it makes working with Coq really
  frustrating.

  #+BEGIN_SRC emacs-lisp
    (setq evil-want-abbrev-expand-on-insert-exit nil)
  #+END_SRC

  Enable =evil=.

  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :init
      (setq evil-want-keybinding nil)
      :config
      (evil-mode 1))
  #+END_SRC

  Enable =evil-collection=

  #+BEGIN_SRC emacs-lisp
    (use-package evil-collection
      :after evil
      :config
      (evil-collection-init))
  #+END_SRC

  Enable =surround= everywhere.

  #+BEGIN_SRC emacs-lisp
    (use-package evil-surround
      :config
      (global-evil-surround-mode 1))
  #+END_SRC

  Use =evil= with Org agendas.

  #+BEGIN_SRC emacs-lisp
    (use-package evil-org
      :diminish evil-org-mode
      :after org
      :config
      (add-hook 'org-mode-hook 'evil-org-mode)
      (add-hook 'evil-org-mode-hook
                (lambda () (evil-org-set-key-theme)))
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))
  #+END_SRC

* Utility functions

  Define a big ol' bunch of handy utility functions.

  #+BEGIN_SRC emacs-lisp
    (defun learry/rename-file (new-name)
      (interactive "FNew name: ")
      (let ((filename (buffer-file-name)))
        (if filename
            (progn
              (when (buffer-modified-p)
                (save-buffer))
              (rename-file filename new-name t)
              (kill-buffer (current-buffer))
              (find-file new-name)
              (message "Renamed '%s' -> '%s'" filename new-name))
          (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

    (defun learry/generate-scratch-buffer ()
      "Create and switch to a temporary scratch buffer with a random
         name."
      (interactive)
      (switch-to-buffer (make-temp-name "scratch-")))

    (defun learry/kill-current-buffer ()
      "Kill the current buffer without prompting."
      (interactive)
      (kill-buffer (current-buffer)))

    (defun learry/visit-last-migration ()
      "Open the most recent Rails migration. Relies on projectile."
      (interactive)
      (let ((migrations
             (directory-files
              (expand-file-name "db/migrate" (projectile-project-root)) t)))
        (find-file (car (last migrations)))))

    (defun learry/add-auto-mode (mode &rest patterns)
      "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
      (dolist (pattern patterns)
        (add-to-list 'auto-mode-alist (cons pattern mode))))

    (defun learry/find-file-as-sudo ()
      (interactive)
      (let ((file-name (buffer-file-name)))
        (when file-name
          (find-alternate-file (concat "/sudo::" file-name)))))

    (defun learry/region-or-word ()
      (if mark-active
          (buffer-substring-no-properties (region-beginning)
                                          (region-end))
        (thing-at-point 'word)))

    (defun learry/append-to-path (path)
      "Add a path both to the $PATH variable and to Emacs' exec-path."
      (setenv "PATH" (concat (getenv "PATH") ":" path))
      (add-to-list 'exec-path path))
  #+END_SRC

* UI preferences
** Tweak window chrome

   I don't usually use the menu or scroll bar, and they take up useful space.

   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode 0)
     (menu-bar-mode 0)
     (scroll-bar-mode -1)
   #+END_SRC

   There is problem with =linum= and big files so I will disable it for the ones defined in
   =linum-disabled-modes-list=.

   #+BEGIN_SRC emacs-lisp
     ;;(global-linum-mode t)
     (load-file "~/.emacs.d/scripts/linum-off.el")
     (linum-on)
   #+END_SRC

   There's a tiny scroll bar that appears in the minibuffer window. This disables
   that:

   #+BEGIN_SRC emacs-lisp
     (set-window-scroll-bars (minibuffer-window) nil nil)
   #+END_SRC

   The default frame title isn't useful. This binds it to the name of the current
   project:

   #+BEGIN_SRC emacs-lisp
     (setq frame-title-format '((:eval (projectile-project-name))))
   #+END_SRC

** Use fancy lambdas

   Why not?

   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode t)
   #+END_SRC

** Load up a theme

   I'm currently using the "zenburn" theme with transparency.

   #+BEGIN_SRC emacs-lisp
     (use-package zenburn-theme)

     (defun transparency (value)
       "Sets the transparency of the frame window. 0=transparent/100=opaque."
       (interactive "nTransparency Value 0 - 100 opaque:")
       (set-frame-parameter (selected-frame) 'alpha value))

     (defun learry/apply-theme ()
       "Apply the `zenburn' theme and make frames just slightly transparent."
       (interactive)
       (load-theme 'zenburn t)
       (transparency 97))
   #+END_SRC

   If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
   frame is themed appropriately.

   #+BEGIN_SRC emacs-lisp
     (if (daemonp)
         (add-hook 'after-make-frame-functions
                   (lambda (frame)
                     (with-selected-frame frame (learry/apply-theme))))
       (learry/apply-theme))
   #+END_SRC

** Configure =powerline=

   #+BEGIN_SRC emacs-lisp
     (use-package powerline
       :config
       (powerline-default-theme))
   #+end_SRC

** Disable visual bell

   =sensible-defaults= replaces the audible bell with a visual one, but I really
   don't even want that (and my Emacs/Mac pair renders it poorly). This disables
   the bell altogether.

   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC

** Scroll conservatively

   When point goes outside the window, Emacs usually recenters the buffer point.
   I'm not crazy about that. This changes scrolling behavior to only scroll as far
   as point goes.

   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 100)
   #+END_SRC

** Set default font and configure font resizing

   I'm partial to Inconsolata.

   The standard =text-scale-= functions just resize the text in the current buffer;
   I'd generally like to resize the text in /every/ buffer, and I usually want to
   change the size of the modeline, too (this is especially helpful when
   presenting). These functions and bindings let me resize everything all together!

   Note that this overrides the default font-related keybindings from
   =sensible-defaults=.

   #+BEGIN_SRC emacs-lisp
     (setq learry/default-font "Inconsolata for Powerline")
     (setq learry/default-font-size 12)
     (setq learry/current-font-size learry/default-font-size)

     (setq learry/font-change-increment 1.1)

     (defun learry/font-code ()
       "Return a string representing the current font (like \"Inconsolata-14\")."
       (concat learry/default-font "-" (number-to-string learry/current-font-size)))

     (defun learry/set-font-size ()
       "Set the font to `learry/default-font' at `learry/current-font-size'.
     Set that for the current frame, and also make it the default for
     other, future frames."
       (let ((font-code (learry/font-code)))
         (add-to-list 'default-frame-alist (cons 'font font-code))
         (set-frame-font font-code)))

     (defun learry/reset-font-size ()
       "Change font size back to `learry/default-font-size'."
       (interactive)
       (setq learry/current-font-size learry/default-font-size)
       (learry/set-font-size))

     (defun learry/increase-font-size ()
       "Increase current font size by a factor of `learry/font-change-increment'."
       (interactive)
       (setq learry/current-font-size
             (ceiling (* learry/current-font-size learry/font-change-increment)))
       (learry/set-font-size))

     (defun learry/decrease-font-size ()
       "Decrease current font size by a factor of `learry/font-change-increment', down to a minimum size of 1."
       (interactive)
       (setq learry/current-font-size
             (max 1
                  (floor (/ learry/current-font-size learry/font-change-increment))))
       (learry/set-font-size))

     (define-key global-map (kbd "C-)") 'learry/reset-font-size)
     (define-key global-map (kbd "C-+") 'learry/increase-font-size)
     (define-key global-map (kbd "C--") 'learry/decrease-font-size)

     (learry/reset-font-size)
   #+END_SRC

** Highlight the current line

   =global-hl-line-mode= softly highlights the background color of the line
   containing point. It makes it a bit easier to find point, and it's useful when
   pairing or presenting code.

   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode)
   #+END_SRC

** Diminish unnecessary modes

   #+BEGIN_SRC emacs-lisp
     (use-package diminish)
   #+END_SRC

   Highlight uncommitted changes

   Use the =diff-hl= package to highlight changed-and-uncommitted lines when
   programming.

   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :config
       (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
       (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
   #+END_SRC

** Setup splash screen

   The default splash screen is not very useful so it is replaced.

   #+BEGIN_SRC emacs-lisp
     (use-package dashboard
       :ensure t
       :config
       (dashboard-setup-startup-hook))
   #+END_SRC

* Project management

  I use a few packages in virtually every programming or writing environment to
  manage the project, handle auto-completion, search for terms, and deal with
  version control. That's all in here.

** =ag=

   Set up =ag= for displaying search results.

   #+BEGIN_SRC emacs-lisp
     (use-package ag)
   #+END_SRC

** =company=
   Use =company-mode= everywhere.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :defer t
       :init (global-company-mode)
       :diminish company-mode)
     (add-hook 'after-init-hook 'global-company-mode)
   #+END_SRC

   Set default backends for company

   #+BEGIN_SRC emacs-lisp
     (setq company-backends
           '((company-files          ; files & directory
              company-keywords       ; keywords
              company-capf           ; `completion-at-point-functions'
              company-yasnippet
              )
             (company-abbrev company-dabbrev)
             ))
   #+END_SRC

   Use =M-/= for completion.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-/") 'company-complete-common)
   #+END_SRC

** =dump-jump=

   The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
   doesn't require any additional setup. I've bound its most useful command to
   =M-.=.

   #+BEGIN_SRC emacs-lisp
     (use-package dumb-jump
       :config
       (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
       (setq dumb-jump-selector 'ivy))
   #+END_SRC

** =flycheck=

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :diminish flycheck-mode)
   #+END_SRC

** =magit=

   I use =magit= to handle version control. It's lovely, but I tweak a few things:

   - I bring up the status menu with =C-x g=.
   - Use =evil= keybindings with =magit=.
   - The default behavior of =magit= is to ask before pushing. I haven't had any
     problems with accidentally pushing, so I'd rather not confirm that every time.
   - Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
     beyond 50 characters.
   - On the command line I'll generally push a new branch with a plain old =git
     push=, which automatically creates a tracking branch on (usually) =origin=.
     Magit, by default, wants me to manually specify an upstream branch. This binds
     =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
     -v=. Convenient!
   - I'd like to start in the insert state when writing a commit message.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind
       ("C-x g" . magit-status)
       :config
       (use-package with-editor)
       (use-package evil-magit)
       (setq magit-push-always-verify nil)
       (setq git-commit-summary-max-length 50))
   #+END_SRC

   I've been playing around with the newly-released =forge= for managing GitHub PRs
   and issues. Seems slick so far.

   #+BEGIN_SRC emacs-lisp
     ;;  (use-package ghub)
     ;;  (use-package forge)
   #+END_SRC

** =projectile=

   Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
   that I rarely use it (and forget it when I need it). This binds it to the
   easier-to-type =C-c v= to useful searches.

   Bind =C-p= to fuzzy-finding files in the current project. We also need to
   explicitly set that in a few other modes.

   I use =ivy= as my completion system.

   When I visit a project with =projectile-switch-project=, the default action is
   to search for a file in that project. I'd rather just open up the top-level
   directory of the project in =dired= and find (or create) new files from there.

   I'd like to /always/ be able to recursively fuzzy-search for files, not just
   when I'm in a Projectile-defined project. I use the current directory as a
   project root (if I'm not in a "real" project).

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :diminish projectile-mode
       :bind
       ("C-c v" . 'projectile-ag)

       :config
       (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
       (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
       (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

       (setq projectile-completion-system 'ivy)
       (setq projectile-switch-project-action 'projectile-dired)
       (setq projectile-require-project-root nil))
   #+END_SRC

** =undo-tree=

   I like tree-based undo management. I only rarely need it, but when I do, oh boy.

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :diminish undo-tree-mode)
   #+END_SRC

* Programming environments

  I like shallow indentation, but tabs are displayed as 8 characters by default.
  This reduces that.

  #+BEGIN_SRC emacs-lisp
    (setq-default tab-width 2)
  #+END_SRC

  Treating terms in CamelCase symbols as separate words makes editing a little
  easier for me, so I like to use =subword-mode= everywhere.

  #+BEGIN_SRC emacs-lisp
    (use-package subword
      :diminish subword-mode
      :config (global-subword-mode 1))
  #+END_SRC

  Compilation output goes to the =*compilation*= buffer. I rarely have that window
  selected, so the compilation output disappears past the bottom of the window.
  This automatically scrolls the compilation window so I can always see the
  output.

  #+BEGIN_SRC emacs-lisp
    ;;  (setq compilation-scroll-output t)
  #+END_SRC

** Coq

   I use =company-coq-mode=, which really helps make Proof General a more useful IDE.

   #+BEGIN_SRC emacs-lisp
     (use-package company-coq
       :defer t)
   #+END_SRC

   I bind the right and left arrow keys to evaluating and retracting the next and
   previous statements. This is more convenient than the default bindings of =C-c
   C-n= and =C-c C-u=.

   I also like to disable =abbrev-mode=; it has a ton of abbreviations for Coq, but
   they've always been unpleasant surprises for me.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'coq-mode-hook
               (lambda ()
                 (company-coq-mode)
                 (evil-define-key 'normal coq-mode-map (kbd "<down>") 'proof-assert-next-command-interactive)
                 (evil-define-key 'normal coq-mode-map (kbd "<up>") 'proof-undo-last-successful-command)
                 (evil-define-key 'normal coq-mode-map (kbd "<return>") 'company-coq-proof-goto-point)
                 (abbrev-mode 0)))
   #+END_SRC

   The default Proof General layout stacks the code, goal, and response buffers on
   top of each other. I like to keep my code on one side and my goal and response
   buffers on the other.

   #+BEGIN_SRC emacs-lisp
     (setq proof-three-window-mode-policy 'hybrid)
   #+END_SRC

   Don't move point when asserting and undoing proof commands.

   #+BEGIN_SRC emacs-lisp
     (setq proof-follow-mode 'ignore)
   #+END_SRC

   The Proof General splash screen's pretty cute, but I don't need to see it every
   time.

   #+BEGIN_SRC emacs-lisp
     (setq proof-splash-enable nil)
   #+END_SRC

   Proof General usually evaluates each comment individually. In literate programs,
   this can result in evaluating a /ton/ of comments. This evaluates a series of
   consecutive comments as a single comment.

   #+BEGIN_SRC emacs-lisp
     (setq proof-script-fly-past-comments t)
   #+END_SRC

** CSS, Sass and Less

   Indent by 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (use-package css-mode
       :config
       (setq css-indent-offset 2))
   #+END_SRC

   Don't compile the current SCSS file every time I save.

   #+BEGIN_SRC emacs-lisp
     (use-package scss-mode
       :config
       (setq scss-compile-at-save nil))
   #+END_SRC

   Install Less.

   #+BEGIN_SRC emacs-lisp
     (use-package less-css-mode)
   #+END_SRC

** Golang

   Install =go-mode= and related packages:

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode)
     (use-package go-errcheck)
     (use-package company-go)
     (use-package go-eldoc)
   #+END_SRC

   Define my =$GOPATH= and tell Emacs where to find the Go binaries.

   #+BEGIN_SRC emacs-lisp
     (setenv "GOPATH" "/home/olearry/dev/Go")
     (learry/append-to-path (concat (getenv "GOPATH") "/bin"))
   #+END_SRC

   Run =goimports= on every file when saving, which formats the file and
   automatically updates the list of imports. This requires that the =goimports=
   binary be installed.

   #+BEGIN_SRC emacs-lisp
     (setq gofmt-command "goimports")
     (add-hook 'before-save-hook 'gofmt-before-save)
   #+END_SRC

   When I open a Go file,

   - Start up =company-mode= with the Go backend. This requires that the =gocode=
     binary is installed,
   - Redefine the default =compile= command to something Go-specific, and
   - Enable =flycheck=.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'go-mode-hook
               (lambda ()
                 (company-mode)
                 (go-eldoc-setup)
                 (set (make-local-variable 'company-backends) '(company-go))
                 (if (not (string-match "go" compile-command))
                     (set (make-local-variable 'compile-command)
                          "go build -v && go test -v && go vet"))
                 (flycheck-mode)))
   #+END_SRC


** Haml and Slim

   Install the Haml and Slim packages.

   #+BEGIN_SRC emacs-lisp
     (use-package haml-mode)
     (use-package slim-mode)
   #+END_SRC

   If I'm editing Haml or Slim templates I'm probably in a Rails project. In that
   case, I'd like to still be able to run my tests from the appropriate buffers.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'slim-mode-hook 'rspec-mode)
     (add-hook 'haml-mode-hook 'rspec-mode)
   #+END_SRC

** Haskell

   Install the =haskell-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :diminish haskell-doc-mode
       :diminish haskell-indent-mode
       :bind (:map haskell-mode-map
                   ("M-g i" . haskell-navigate-imports)
                   ("M-g M-i" . haskell-navigate-imports)))
   #+END_SRC

   Company for ghc

   #+BEGIN_SRC emacs-lisp
     (use-package company-ghc
       :after company
       :config (add-to-list 'company-backends 'company-ghc))
   #+END_SRC

   Random snippet I copied from [[https://github.com/cydparser/demo-emacs-haskell][cydparser]].

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-snippets
       :defer t)

     (use-package hlint-refactor
       :defer t
       :diminish ""
       :init (add-hook 'haskell-mode-hook #'hlint-refactor-mode))

     (use-package intero
     :defer t
     :diminish " λ"
     :bind (:map intero-mode-map
                 ("M-." . init-intero-goto-definition))
     :init
     (progn
       (defun init-intero ()
         "Enable Intero unless visiting a cached dependency."
         (if (and buffer-file-name
                  (string-match ".+/\\.\\(stack\\|stack-work\\)/.+" buffer-file-name))
             (progn
               (eldoc-mode -1)
               (flycheck-mode -1))
           (intero-mode)
           (set (make-local-variable 'projectile-tags-command) "codex update")))

       (add-hook 'haskell-mode-hook #'init-intero))
     :config
     (progn
       (defun init-intero-goto-definition ()
         "Jump to the definition of the thing at point using Intero or etags."
         (interactive)
         (or (intero-goto-definition)
             (find-tag (find-tag-default))))

       (flycheck-add-next-checker 'intero '(warning . haskell-hlint))))
   #+END_SRC

   Install =ghc-mod= but it needs to be loaded after =haskell-mode=. Doesn't
   work at the moment because =ghc-mod= is not compatible with the current =ghc= version.

   #+BEGIN_SRC emacs-lisp
     ;(use-package ghc
     ;  :config
     ;  (autoload 'ghc-init "ghc" nil t)
     ;  (autoload 'ghc-debug "ghc" nil t))
   #+END_SRC

     Enable =haskell-doc-mode=, which displays the type signature of a function, and
     use smart indentation.

   #+BEGIN_SRC emacs-lisp
       (add-hook 'haskell-mode-hook
                 (lambda ()
                   (haskell-doc-mode)
                   (turn-on-haskell-indent)
                   (ghc-init)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (learry/append-to-path "~/.cabal/bin")
   #+END_SRC

** Javascript and CoffeeScript

   Install =coffee-mode= from editing CoffeeScript code.

   #+BEGIN_SRC emacs-lisp
     (use-package coffee-mode)
   #+END_SRC

   Indent everything by 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (setq js-indent-level 2)

     (add-hook 'coffee-mode-hook
               (lambda ()
                 (yas-minor-mode 1)
                 (setq coffee-tab-width 2)))
   #+END_SRC

** LaTeX

   Making sure that the LaTeX is installed and makes sure that auctex is there as well. There's a bind with F12 to correct
   the last word that is not correctly spelled.

   #+BEGIN_SRC emacs-lisp
     (use-package tex
       :defer t
       :ensure auctex
       :bind
       ([f12] . flyspell-auto-correct-previous-word))
   #+END_SRC

   Add flyspell mode to latex and reftex

   #+BEGIN_SRC emacs-lisp
     (setq-default TeX-master nil)
     (add-hook 'LaTeX-mode-hook 'flyspell-mode)
     (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
     (setq reftex-plug-into-AUCTeX t)
   #+END_SRC

   Automatically parse the file after loading it as well as save it automatically.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-auto-save t)
     (setq TeX-parse-self t)
   #+END_SRC

   Always use =pdflatex= when compiling LaTeX documents. I don't really have any
   use for DVIs.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-PDF-mode t)
   #+END_SRC

   Open compiled PDFs in =evince= instead of in the editor.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook
               '(lambda ()
                  (delete '("\\.pdf\\'" . default) org-file-apps)
                  (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince %s"))))
   #+END_SRC

   Enable a minor mode for dealing with math (it adds a few useful keybindings),
   and always treat the current file as the "main" file. That's intentional, since
   I'm usually actually in an org document.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'LaTeX-mode-hook
               (lambda ()
                 (LaTeX-math-mode)
                 (setq TeX-master t)))
   #+END_SRC

** Lisps

   I like to use =paredit= in Lisp modes to balance parentheses (and more!).

   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :diminish "π")
   #+END_SRC

   =rainbow-delimiters= is convenient for coloring matching parentheses.

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters)
   #+END_SRC

   All the lisps have some shared features, so we want to do the same things for
   all of them. That includes using =paredit=, =rainbow-delimiters=, and
   highlighting the whole expression when point is on a parenthesis.

   #+BEGIN_SRC emacs-lisp
     (setq lispy-mode-hooks
           '(clojure-mode-hook
             emacs-lisp-mode-hook
             lisp-mode-hook
             scheme-mode-hook))

     (dolist (hook lispy-mode-hooks)
       (add-hook hook (lambda ()
                        (setq show-paren-style 'expression)
                        (paredit-mode)
                        (rainbow-delimiters-mode))))
   #+END_SRC

   If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
   documentation.

   #+BEGIN_SRC emacs-lisp
     (use-package eldoc
       :diminish eldoc-mode
       :config
       (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
   #+END_SRC

   I also like using =flycheck-package= to ensure that my Elisp packages are
   correctly formatted.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-package)

     (eval-after-load 'flycheck
       '(flycheck-package-setup))
   #+END_SRC

** Python

   #+BEGIN_SRC emacs-lisp
     (use-package python-mode
       :diminish (python-mode . "Py"))
   #+END_SRC

   Add =~/.local/bin= to load path. That's where =virtualenv= is installed, and
   we'll need that for =jedi=.

   #+BEGIN_SRC emacs-lisp
     (learry/append-to-path "~/.local/bin")
   #+END_SRC

   Enable =elpy=. This provides automatic indentation, auto-completion, syntax
   checking, etc.

   #+BEGIN_SRC emacs-lisp
     (use-package elpy)
     (elpy-enable)
   #+END_SRC

   Use =flycheck= for syntax checking:

   #+BEGIN_SRC emacs-lisp
     (add-hook 'elpy-mode-hook 'flycheck-mode)
   #+END_SRC

   Format code according to PEP8 on save:

   #+BEGIN_SRC emacs-lisp
     (use-package py-autopep8)
     (require 'py-autopep8)
     (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
   #+END_SRC

   Configure Jedi along with the associated =company= mode:

   #+BEGIN_SRC emacs-lisp
     (use-package company-jedi)
     (add-to-list 'company-backends 'company-jedi)

     (add-hook 'python-mode-hook 'jedi:setup)
     (setq jedi:complete-on-dot t)
   #+END_SRC

** Ruby and RSpec

   I use =chruby= to switch between versions of Ruby. This sets a default version
   to use within Emacs (for things like =xmp= or =rspec=).

   #+BEGIN_SRC emacs-lisp
     (setq learry/ruby-version "2.5.3")

     (use-package chruby
       :config
       (chruby learry/ruby-version))
   #+END_SRC

   Ruby executables are installed in =~/.gem/ruby/<version>/bin=. This ensures that
   that's included in the path. In particular, we want that directory to be
   included because it contains the =xmpfilter= executable, which is used below.

   #+BEGIN_SRC emacs-lisp
     (learry/append-to-path (format "~/.gem/ruby/%s/bin" learry/ruby-version))
   #+END_SRC

   Running tests from within Emacs is awfully convenient.

   #+BEGIN_SRC emacs-lisp
     ;;  (use-package rspec-mode)
   #+END_SRC

   =rcodetools= provides =xmp=, which lets me evaluate a Ruby buffer and display
   the results in "magic" (=# =>=) comments.

   I disable warnings when running code through =xmp= because I disagree with a few
   of them (complaining about private =attr_reader=, especially) and they gunk up
   my buffer.

   #+BEGIN_SRC emacs-lisp
     ;;  (setq xmpfilter-command-name
     ;;        "ruby -S xmpfilter --no-warnings --dev --fork --detect-rbtest")
     ;;  (require 'rcodetools)
   #+END_SRC

   I like running Rubocop through Flycheck, but it also invokes Reek, which I've
   found to be more of a nuisance than a help. This disables the =ruby-reek=
   checker:

   #+BEGIN_SRC emacs-lisp
     ;;  (setq-default flycheck-disabled-checkers '(ruby-reek))
   #+END_SRC

   When assigning the result of a conditional, I like to align the expression to
   match the beginning of the statement instead of indenting it all the way to the
   =if=.

   #+BEGIN_SRC emacs-lisp
     ;;  (setq ruby-align-to-stmt-keywords '(def if))
   #+END_SRC

   Ruby method comments are often formatted with Yard.

   #+BEGIN_SRC emacs-lisp
     (use-package yard-mode
       :diminish yard-mode)
   #+END_SRC

   Insert =end= keywords automatically when I start to define a method, class,
   module, or block.

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-end
       :diminish ruby-end-mode)
   #+END_SRC

   Install and enable =projectile-rails= mode in all Rail-related buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile-rails
       :config
       (projectile-rails-global-mode))
   #+END_SRC

   There are a bunch of things I'd like to do when I open a Ruby buffer:

   - I don't want to insert an encoding comment.
   - I want to enable =yas=, =rspec=, =yard=, =flycheck=, and =projectile-rails=.
   - I'd like my RSpec tests to be run in a random order, and I'd like the output
     to be colored.
   - Chruby should automatically determine the correct version for me.
   - =C-c C-c= should run =xmp=, to do that nifty "eval into comments" trick.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'ruby-mode-hook
               (lambda ()
                 (setq ruby-insert-encoding-magic-comment nil)
                 (yas-minor-mode)
                 (rspec-mode)
                 (yard-mode)
                 (flycheck-mode)
                 (local-set-key "\r" 'newline-and-indent)
                 (setq rspec-command-options "--color --order random")
                 (chruby-use-corresponding)
                 (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)))
   #+END_SRC

   I associate =ruby-mode= with Gemfiles, gemspecs, Rakefiles, and Vagrantfiles.

   #+BEGIN_SRC emacs-lisp
     (learry/add-auto-mode
      'ruby-mode
      "\\Gemfile$"
      "\\.rake$"
      "\\.gemspec$"
      "\\Guardfile$"
      "\\Rakefile$"
      "\\Vagrantfile$"
      "\\Vagrantfile.local$")
   #+END_SRC

   When running RSpec tests I'd like to scroll to the first error.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'rspec-compilation-mode-hook
               (lambda ()
                 (make-local-variable 'compilation-scroll-output)
                 (setq compilation-scroll-output 'first-error)))
   #+END_SRC

** =sh=

   Indent with 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'sh-mode-hook
               (lambda ()
                 (setq sh-basic-offset 2
                       sh-indentation 2)))
   #+END_SRC

** Scala

   Ensure that =scala-mode= and =sbt-mode= are installed.

   #+BEGIN_SRC emacs-lisp
     (use-package scala-mode
       :interpreter
       ("scala" . scala-mode))
     (use-package sbt-mode)
   #+END_SRC

   Don't show the startup message with launching ENSIME:

   #+BEGIN_SRC emacs-lisp
     (setq ensime-startup-notification nil)
   #+END_SRC

   Bind a few keys to common operations:

   #+BEGIN_SRC emacs-lisp
     (evil-define-key 'normal ensime-mode-map (kbd "C-t") 'ensime-type-at-point)
     (evil-define-key 'normal ensime-mode-map (kbd "M-.") 'ensime-edit-definition)
   #+END_SRC

** =web-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode)
   #+END_SRC

   If I'm in =web-mode=, I'd like to:

   - Color color-related words with =rainbow-mode=.
   - Still be able to run RSpec tests from =web-mode= buffers.
   - Indent everything with 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'web-mode-hook
               (lambda ()
                 (rainbow-mode)
                 (rspec-mode)
                 (setq web-mode-markup-indent-offset 2)))
   #+END_SRC

   Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

   #+BEGIN_SRC emacs-lisp
     (learry/add-auto-mode
      'web-mode
      "\\.erb$"
      "\\.html$"
      "\\.php$"
      "\\.rhtml$")
   #+END_SRC

** YAML

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode)
   #+END_SRC

   If I'm editing YAML I'm usually in a Rails project. I'd like to be able to run
   the tests from any buffer.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'yaml-mode-hook 'rspec-mode)
   #+END_SRC

** Terminal

   I use =multi-term= to manage my shell sessions. It's bound to =C-c t=.

   #+BEGIN_SRC emacs-lisp
     (use-package multi-term)
     (global-set-key (kbd "C-c t") 'multi-term)
   #+END_SRC

   Use a login shell:

   #+BEGIN_SRC emacs-lisp
     (setq multi-term-program-switches "--login")
   #+END_SRC

   I'd rather not use Evil in the terminal. It's not especially useful (I don't use
   vi bindings in xterm) and it shadows useful keybindings (=C-d= for EOF, for
   example).

   #+BEGIN_SRC emacs-lisp
     (evil-set-initial-state 'term-mode 'emacs)
   #+END_SRC

   I add a bunch of hooks to =term-mode=:

   - I'd like links (URLs, etc) to be clickable.
   - Yanking in =term-mode= doesn't quite work. The text from the paste appears in
     the buffer but isn't sent to the shell process. This correctly binds =C-y= and
     middle-click to yank the way we'd expect.
   - I bind =M-o= to quickly change windows. I'd like that in terminals, too.
   - I don't want to perform =yasnippet= expansion when tab-completing.

   #+BEGIN_SRC emacs-lisp
     (defun learry/term-paste (&optional string)
       (interactive)
       (process-send-string
        (get-buffer-process (current-buffer))
        (if string string (current-kill 0))))

     (add-hook 'term-mode-hook
               (lambda ()
                 (goto-address-mode)
                 (define-key term-raw-map (kbd "C-y") 'learry/term-paste)
                 (define-key term-raw-map (kbd "<mouse-2>") 'learry/term-paste)
                 (define-key term-raw-map (kbd "M-o") 'other-window)
                 (setq yas-dont-activate t)))
   #+END_SRC

* Publishing and task management with Org-mode

  #+BEGIN_SRC emacs-lisp
  (use-package org
    :diminish org-indent-mode)
#+END_SRC

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

Quickly insert a block of elisp:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

** Task and org-capture management

For autocomplete with company we have to add =pcomplete-completion-at-point= to =completion-at-point-functions=

#+BEGIN_SRC emacs-lisp
  (defun add-completion-to-org-hook ()
    (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
  (add-hook 'org-mode-hook #'add-completion-to-org-hook)
#+END_SRC

Store my org files in =~/Documents/Dropbox/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/Documents/Dropbox/org/archive.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Documents/Dropbox/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/Documents/Dropbox/org/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
#+END_SRC

I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
append them to an "inbox.org" file in my Dropbox. This function lets me import
them easily from that inbox file to my index.

#+BEGIN_SRC emacs-lisp
  (defun learry/copy-tasks-from-inbox ()
    (when (file-exists-p org-inbox-file)
      (save-excursion
        (find-file org-index-file)
        (goto-char (point-max))
        (insert-file-contents org-inbox-file)
        (delete-file org-inbox-file))))
#+END_SRC

I store all my todos in =~/Documents/Dropbox/org/index.org=, so I'd like to derive my
agenda from there.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-index-file))
#+END_SRC

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+BEGIN_SRC emacs-lisp
  (defun learry/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'learry/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

*** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Maintain a todo list in =~/Documents/org/index.org=.
- Convert emails into todos to maintain an empty inbox.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("e" "Email" entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n\n%a\n\n")

          ("f" "Finished book"
           table-line (file "~/Documents/Dropbox/notes/books-read.org")
           "| %^{Title} | %^{Author} | %u |")

          ("r" "Reading"
           checkitem
           (file (org-file-path "to-read.org")))

          ("s" "Subscribe to an RSS feed"
           plain
           (file "~/Documents/Dropbox/rss/urls")
           "%^{Feed URL} \"~%^{Feed name}\"")

          ("t" "Todo"
           entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n")))
#+END_SRC

When I'm starting an Org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

Refiling according to the document's hierarchy.

#+BEGIN_SRC emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

*** Keybindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

Hit =C-c i= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun learry/open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (learry/copy-tasks-from-inbox)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'learry/open-index-file)
#+END_SRC

Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

** =Interleave=
With the =interleave= package notes can be taken in a pdf. We first have to add interleave.

#+BEGIN_SRC emacs-lisp
  (use-package interleave)
#+END_SRC

Add a hook that fits the page to the current window and changes the local fill-column to 80.

#+BEGIN_SRC emacs-lisp
  (defun learry/interleave-hook ()
    "Hooks for interleave mode
     set the local column width to 80 and fit the page to the window"
    (doc-view-fit-page-to-window)
    (other-window)
    (set (make-local-variable 'fill-column) 70))
  (add-hook 'interleave-mode-hook 'learry/interleave-hook)
#+END_SRC

** Exporting

Allow export to markdown and beamer (for presentations).

#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

Allow =babel= to evaluate Emacs lisp, Ruby, dot, or Gnuplot code.

#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Associate the "dot" language with the =graphviz-dot= major mode.

#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode)
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+BEGIN_SRC emacs-lisp
  (setq org-export-with-smart-quotes t)
#+END_SRC

*** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")

  (setenv "BROWSER" "firefox")
#+END_SRC

*** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Include the =minted= package in all of my LaTeX exports.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+END_SRC

*** Exporting projects

I have a few Org project definitions that I maintain in a separate elisp file.

#+BEGIN_SRC emacs-lisp
;;  (load-file ".emacs.d/projects.el")
#+END_SRC

** Daily checklist

There are certain things I want to do regularly. I store those in a checklist.
Because different things happen on different days, the checklist is an Org
document generated by a Ruby script.

Running =learry/today= either opens today's existing checklist (if it exists), or
renders today's new checklist, copies it into an Org file in =/tmp=, and opens
it.

#+BEGIN_SRC emacs-lisp
  (setq learry/checklist-script "~/bin/daily-checklist")

  (defun learry/today-checklist-filename ()
    "The filename of today's checklist."
    (concat "/home/learry/documents/checklists/daily-checklist-" (format-time-string "%Y-%m-%d") ".org"))

  (defun learry/today ()
    "Take a look at today's checklist."
    (interactive)
    (let ((filename (learry/today-checklist-filename)))
      (if (file-exists-p filename)
          (find-file filename)
        (progn
          (shell-command (concat learry/checklist-script " > " filename))
          (find-file filename)))))
#+END_SRC

Open the checklist and my TODO list side-by-side:

#+BEGIN_SRC emacs-lisp
  (defun learry/dashboard ()
    (interactive)
    (delete-other-windows)
    (learry/today)
    (split-window-right)
    (learry/open-index-file))

  (global-set-key (kbd "C-c d") 'learry/dashboard)
#+END_SRC

* Writing prose
** Enable spell-checking in the usual places

I want to make sure that I've enabled spell-checking if I'm editing text,
composing an email, or authoring a Git commit.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :diminish flyspell-mode

    :config
    (add-hook 'text-mode-hook 'turn-on-auto-fill)
    (add-hook 'gfm-mode-hook 'flyspell-mode)
    (add-hook 'org-mode-hook 'flyspell-mode)

    (add-hook 'git-commit-mode-hook 'flyspell-mode)
    (add-hook 'mu4e-compose-mode-hook 'flyspell-mode))
#+END_SRC

** Look up definitions

I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.

#+BEGIN_SRC emacs-lisp
  (defun learry/dictionary-prompt ()
    (read-string
     (format "Word (%s): " (or (learry/region-or-word) ""))
     nil
     nil
     (learry/region-or-word)))

  (defun learry/dictionary-define-word ()
    (interactive)
    (let* ((word (learry/dictionary-prompt))
           (buffer-name (concat "Definition: " word)))
      (with-output-to-temp-buffer buffer-name
        (shell-command (format "sdcv -n %s" word) buffer-name))))

  (define-key global-map (kbd "C-x w") 'learry/dictionary-define-word)
#+END_SRC

** Look up words in a thesaurus

Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-x s= searches for synonyms.

#+BEGIN_SRC emacs-lisp
  (use-package synosaurus)
  (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
  (add-hook 'after-init-hook #'synosaurus-mode)
  (define-key global-map "\C-xs" 'synosaurus-lookup)
#+END_SRC

** Editing with Markdown

Because I can't always use =org=.

- Associate =.md= files with GitHub-flavored Markdown.
- Use =pandoc= to render the results.
- Leave the code block font unchanged.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands gfm-mode

    :mode (("\\.md$" . gfm-mode))

    :config
    (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
    (custom-set-faces
     '(markdown-code-face ((t nil)))))
#+END_SRC

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
  (add-hook 'gfm-mode-hook 'auto-fill-mode)
  (add-hook 'org-mode-hook 'auto-fill-mode)
#+END_SRC

I don't really need to see the auto-fill indicator, though. We need to diminish
on a confusing name for [[https://github.com/magnars/.emacs.d/blob/master/site-lisp/diminish.el#L87][historical reasons]].

#+BEGIN_SRC emacs-lisp
  (diminish 'auto-fill-function)
#+END_SRC

** Cycle between spacing alternatives

Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= is strictly better than the original binding of
=just-one-space=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
#+END_SRC

** Linting prose

I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

Use flycheck in the appropriate buffers:

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  (add-hook 'gfm-mode-hook #'flycheck-mode)
  (add-hook 'text-mode-hook #'flycheck-mode)
  (add-hook 'org-mode-hook #'flycheck-mode)
#+END_SRC

** Enable region case modification

#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC

** Quickly exlore my "notes" directory with =deft=

#+BEGIN_SRC emacs-lisp
  (use-package deft
    :bind ("C-c n" . deft)
    :commands (deft)
    :config

    (setq deft-directory "~/documents/notes"
          deft-recursive t
          deft-use-filename-as-title t)

    (evil-set-initial-state 'deft-mode 'emacs))
#+END_SRC

* =dired=

Hide dotfiles by default, but toggle their visibility with =.=.

#+BEGIN_SRC emacs-lisp
  (use-package dired-hide-dotfiles
    :config
    (dired-hide-dotfiles-mode)
    (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
#+END_SRC

Open media with the appropriate programs.

#+BEGIN_SRC emacs-lisp
  (use-package dired-open
    :config
    (setq dired-open-extensions
          '(("pdf" . "evince")
            ("mkv" . "vlc")
            ("mp3" . "vlc")
            ("mp4" . "vlc")
            ("avi" . "vlc"))))
#+END_SRC

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
#+END_SRC

Use "j" and "k" to move around in =dired=.

#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
  (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
#+END_SRC

Kill buffers of files/directories that are deleted in =dired=.

#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking every time.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

Open a file with an external program (that is, through =xdg-open=) by hitting
=C-c C-o=.

#+BEGIN_SRC emacs-lisp
  (defun dired-xdg-open ()
    "In dired, open the file named on this line."
    (interactive)
    (let* ((file (dired-get-filename nil t)))
      (call-process "xdg-open" nil 0 nil file)))

  (define-key dired-mode-map (kbd "C-c C-o") 'dired-xdg-open)
#+END_SRC

* Editing settings
** Quickly visit Emacs configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my Emacs configuration file.

#+BEGIN_SRC emacs-lisp
  (defun learry/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c e") 'learry/visit-emacs-config)
#+END_SRC

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'learry/kill-current-buffer)
#+END_SRC

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+BEGIN_SRC emacs-lisp
  (use-package helpful)

  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
  (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window)
#+END_SRC

** Look for executables in =/usr/local/bin=

#+BEGIN_SRC emacs-lisp
  (learry/append-to-path "/usr/local/bin")
#+END_SRC

** Save my location within a file

Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+BEGIN_SRC emacs-lisp
  (save-place-mode t)
#+END_SRC

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Install and configure =which-key=

=which-key= displays the possible completions for a long keybinding. That's
really helpful for some modes (like =projectile=, for example).

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish
    :config
    (which-key-mode))
#+END_SRC

** Configure =yasnippet=

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode)
#+END_SRC

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+BEGIN_SRC emacs-lisp
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+END_SRC

I /don’t/ want =yas= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** Configure =ivy= and =counsel=

I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :diminish ivy-mode
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :config
    (use-package flx)
    (use-package smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+END_SRC

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp
  (defun learry/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun learry/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'learry/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'learry/split-window-right-and-switch)
#+END_SRC

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+BEGIN_SRC emacs-lisp
  (use-package wgrep)

  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+END_SRC

** Use projectile everywhere

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/learry/engine-mode][engine-mode]] and define a few useful engines.

#+BEGIN_SRC emacs-lisp
  (use-package engine-mode)
  (require 'engine-mode)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine youtube
    "https://www.youtube.com/results?search_query=%s")

  (engine-mode t)
#+END_SRC

* Set custom keybindings

Just a few handy functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-o") 'other-window)
  (global-set-key (kbd "C-c h") 'evil-force-normal-state)
#+END_SRC

Remap when working in terminal Emacs.

#+BEGIN_SRC emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+END_SRC

Correct last wrong written word with =F12=

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f12>") 'flyspell-auto-correct-previous-word)
#+END_SRC

* Extra

#+BEGIN_SRC emacs-lisp
  ;;  (load-file "~/.emacs-private.el")
#+END_SRC
